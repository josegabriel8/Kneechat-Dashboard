import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Cargar datos (ajusta seg√∫n tu archivo)
df = pd.read_excel("bd_c_gpt.xlsx")

# Diccionario de mapeo para categorias1 (c√≥digos del 1 al 10)
DudasFrecuentes = {
    1: "Info general",          
    2: "Preparaci√≥n para la cirug√≠a",           
    3: "Cirug√≠a/Anestesia",     
    4: "Proceso de recuperaci√≥n",          
    5: "Manejo dolor",          
    6: "Complicaciones",        
    7: "Cuidados postop",       
    8: "Expectativas",          
    9: "Recursos Adicionales",              
    10: "Log√≠stica y tiempos de espera"             
}

# Crear una nueva columna con los labels cortos para categorias1
df['DudasFrecuentes'] = df['categorias1'].map(DudasFrecuentes)

# Diccionario de mapeo para categorias2 (c√≥digos del 1 al 6)
map_cat2 = {
    1: "Dolor/Complicaciones",  
    2: "Deseo de operarse",         
    3: "Miedo/preocupaci√≥n/Ansiedad",        
    4: "Confianza y positividad",             
    5: "Rutina diaria",               
    6: "Otros"                  
}

# Crear una nueva columna con los labels cortos para categorias2
df['Tiporeflexi√≥n'] = df['categorias2'].map(map_cat2)

# Configuraci√≥n de la p√°gina
st.set_page_config(page_title="Dashboard de An√°lisis de Texto", layout="wide")

# T√≠tulo principal
st.title("üìä Dashboard de An√°lisis de Comentarios y Preguntas")


st.header("Informaci√≥n del estudio")
st.write("""
**Este tablero presenta la informaci√≥n recopilada en el estudio:**
**'Empleo de canales de comunicaci√≥n digitales para la evaluaci√≥n y detecci√≥n de necesidades de informaci√≥n en pacientes pendientes de intervenci√≥n de Artroplastia Total de Rodilla.'**

- Los datos fueron recolectados a trav√©s de **41 entrevistas telef√≥nicas** realizadas a pacientes con diagn√≥stico de **gonartrosis de rodilla** y con un procedimiento pendiente codificado como **sustituci√≥n total de rodilla**.
""")

st.header("An√°lisis de intervenciones/frases recogidas por pacientes en las entrevistas")
st.write("""
- La informaci√≥n presentada corresponde exclusivamente a las intervenciones realizadas por los pacientes durante las entrevistas.
- Tras el **preprocesamiento de los textos** y la segmentaci√≥n de las intervenciones en **unidades de an√°lisis (frases)**, se aplicaron t√©cnicas de **Procesamiento de Lenguaje Natural (PLN)** para clasificar las frases en tres grandes grupos:

  1Ô∏è‚É£ **Duda/Pregunta:** Frases en las que el paciente expresa una necesidad de informaci√≥n.  
  2Ô∏è‚É£ **Comentario/Reflexi√≥n:** Frases dirigidas al entrevistador (doctor) que contienen informaci√≥n relevante sobre sus circunstancias, sentimientos, preocupaciones, etc.  
  3Ô∏è‚É£ **Interacciones no relevantes:** Saludaciones, despedidas, afirmaciones gen√©ricas u otros comentarios sin valor para el estudio.  

""")


total_pacientes = 41

# Identificar pacientes √∫nicos por tipo
comentario_ids = df[df["Tipo"] == "Comentario/reflexi√≥n"]["num_entrevista"].unique()
duda_ids = df[df["Tipo"] == "Duda/pregunta"]["num_entrevista"].unique()
union_ids = set(comentario_ids) | set(duda_ids)

# Contar pacientes por cada grupo
comentarios_count = len(comentario_ids)
dudas_count = len(duda_ids)
sin_registro = total_pacientes - len(union_ids)

# Preparar DataFrame para el gr√°fico
data = {
    "Tipo": ["Comentario/reflexi√≥n", "Duda/pregunta", "Sin interacci√≥n relevante"],
    "Entrevistas": [comentarios_count, dudas_count, sin_registro]
}
df_plot = pd.DataFrame(data)
df_plot["Porcentaje"] = df_plot["Entrevistas"] / total_pacientes * 100

# Configurar estilo sin grid
sns.set_style("white")

# Gr√°fico 1: Frecuencia de entrevistas
fig, ax = plt.subplots(figsize=(10, 4))
sns.barplot(
    x="Tipo",
    y="Entrevistas",
    data=df_plot,
    order=["Comentario/reflexi√≥n", "Duda/pregunta", "Sin interacci√≥n"],
    color="#cf5c36",  # Color modificado a cf5c36
    ax=ax
)

# Agregar borde a cada barra
for patch in ax.patches:
    patch.set_edgecolor("black")
    patch.set_linewidth(1.5)

ax.set_title("Frecuencia de entrevistas por tipo de informaci√≥n recogida", fontsize=12)
ax.set_ylabel("N√∫mero de entrevistas", fontsize=10)
ylim_max = df_plot["Entrevistas"].max() + 5  
ax.set_ylim(0, ylim_max)

# Anotar porcentaje en cada barra
for index, row in df_plot.iterrows():
    y_value = row["Entrevistas"] + 0.5
    if index == 0 and y_value > ylim_max - 1:
        y_value = row["Entrevistas"] - 0.5
        va = "top"
    else:
        va = "bottom"
    ax.text(index, y_value, f'{row["Porcentaje"]:.1f}%', ha='center', va=va, fontsize=14)

plt.tight_layout()
st.pyplot(fig)


# ---- Gr√°ficos 2 y 3: Frecuencia por categor√≠a con filtro y lado a lado ----
st.subheader("--------------------------------------------------------")
st.header("Frases y pacientes por categor√≠a")

st.write("üìå **En una segunda fase, la clasificaci√≥n se profundiz√≥ a√∫n m√°s utilizando inteligencia artificial.**")
# Clasificaci√≥n de comentarios/reflexiones
st.subheader("üìå Clasificaci√≥n de comentarios/reflexiones")

st.write("""
Para las frases en las que los pacientes expresaban reflexiones o comentarios, que fueron **225**, se establecieron las siguientes categor√≠as:

‚úÖ **Dolor/Complicaciones:** Relacionadas con dolor, sufrimiento o complicaciones f√≠sicas derivadas de la rodilla.  
‚úÖ **Deseo de operarse:** Expresan urgencia por la cirug√≠a o cr√≠ticas sobre la espera prolongada.  
‚úÖ **Miedo/Preocupaci√≥n/Ansiedad:** Reflejan angustia, miedo o inquietudes respecto a la cirug√≠a o el postoperatorio.  
‚úÖ **Confianza y Positividad:** Demuestran seguridad y optimismo respecto al procedimiento y el equipo m√©dico.  
‚úÖ **Rutina diaria:** Describen de manera neutral la vida cotidiana del paciente.  
‚úÖ **Otros:** Frases que no encajan en las categor√≠as anteriores.  
""")

# Clasificaci√≥n de dudas/preguntas
st.subheader("üìå Clasificaci√≥n de dudas/preguntas")
st.write("""
Las frases que reflejaban **necesidad de informaci√≥n (51 en total)** fueron categorizadas con base en la gu√≠a de **Preguntas Frecuentes sobre Pr√≥tesis Total de Rodilla**, que abarca los siguientes temas:

1Ô∏è‚É£ **Informaci√≥n general sobre la artroplastia de rodilla:** Explica qu√© es el procedimiento, su necesidad y comparaciones con otras intervenciones.  
2Ô∏è‚É£ **Preparaci√≥n para la cirug√≠a:** Consejos sobre c√≥mo prepararse f√≠sica y mentalmente, incluyendo cambios en el estilo de vida y adaptaciones en el hogar.  
3Ô∏è‚É£ **Cirug√≠a y anestesia:** Informaci√≥n sobre el preoperatorio, tipo de anestesia, procedimiento quir√∫rgico y recuperaci√≥n inicial.  
4Ô∏è‚É£ **Proceso de recuperaci√≥n:** Expectativas sobre el postoperatorio en hospital y en casa, incluyendo fisioterapia y rehabilitaci√≥n.  
5Ô∏è‚É£ **Manejo del dolor:** Estrategias para aliviar el dolor postoperatorio y detalles sobre medicamentos y efectos secundarios.  
6Ô∏è‚É£ **Complicaciones y riesgos:** Posibles complicaciones, se√±ales de alerta y c√≥mo identificarlas.  
7Ô∏è‚É£ **Cuidados postoperatorios:** Recomendaciones sobre higiene, vendajes, actividad f√≠sica y recuperaci√≥n en casa.  
8Ô∏è‚É£ **Expectativas a largo plazo:** Durabilidad de la pr√≥tesis, nivel de funcionalidad esperado y consejos para el cuidado de la rodilla operada.  
9Ô∏è‚É£ **Recursos adicionales:** Informaci√≥n sobre fuentes confiables para quienes buscan m√°s orientaci√≥n o apoyo.  

üìå **Categor√≠a adicional:**  
üïí **Log√≠stica y tiempos de espera:** Debido a la cantidad de preguntas sobre este tema, se agreg√≥ una categor√≠a espec√≠fica para abordar consultas sobre tiempos de espera, costos, tr√°mites administrativos y pruebas preoperatorias.  
""")





# Bot√≥n de filtro para seleccionar qu√© columnas mostrar
tipo_seleccionado = st.multiselect(
    "Selecciona qu√© frecuencia mostrar:",
    ["Frases", "Pacientes"],
    default=["Frases", "Pacientes"]
)

col1, col2 = st.columns(2)

with col1:
    st.markdown("### Dudas/Preguntas")
    # Agrupar datos para Dudas
    df_dudas = df.groupby("DudasFrecuentes").agg(
        Frases=("DudasFrecuentes", "count"),
        Pacientes=("num_entrevista", "nunique")
    ).reset_index().sort_values(by="Frases", ascending=False)
    
    # Convertir a formato largo
    df_dudas_melted = df_dudas.melt(id_vars="DudasFrecuentes", var_name="Tipo", value_name="Frecuencia")
    # Filtrar seg√∫n selecci√≥n
    df_dudas_melted = df_dudas_melted[df_dudas_melted["Tipo"].isin(tipo_seleccionado)]
    
    fig2, ax2 = plt.subplots(figsize=(10, 6))
    sns.barplot(
        data=df_dudas_melted,
        x="DudasFrecuentes",
        y="Frecuencia",
        hue="Tipo",
        palette={"Frases": "#cf5c36", "Pacientes": "#93B7BE"},
        ax=ax2
    )
    ax2.set_xticklabels(ax2.get_xticklabels(), rotation=45, ha="right")
    ax2.set_xlabel("Categor√≠a de Dudas")
    ax2.set_ylabel("Frecuencia")
    ax2.legend(title="Tipo")
    for container in ax2.containers:
        ax2.bar_label(container, fmt='%d', label_type='edge', fontsize=12)
    plt.tight_layout()
    st.pyplot(fig2)

with col2:
    st.markdown("### Reflexiones/Comentarios")
    # Agrupar datos para Reflexiones
    df_reflexion = df.groupby("Tiporeflexi√≥n").agg(
        Frases=("Tiporeflexi√≥n", "count"),
        Pacientes=("num_entrevista", "nunique")
    ).reset_index().sort_values(by="Frases", ascending=False)
    
    # Convertir a formato largo
    df_reflexion_melted = df_reflexion.melt(id_vars="Tiporeflexi√≥n", var_name="Tipo", value_name="Frecuencia")
    # Filtrar seg√∫n selecci√≥n
    df_reflexion_melted = df_reflexion_melted[df_reflexion_melted["Tipo"].isin(tipo_seleccionado)]
    
    fig3, ax3 = plt.subplots(figsize=(10, 6))
    sns.barplot(
        data=df_reflexion_melted,
        x="Tiporeflexi√≥n",
        y="Frecuencia",
        hue="Tipo",
        palette={"Frases": "#cf5c36", "Pacientes": "#93B7BE"},
        ax=ax3
    )
    ax3.set_xticklabels(ax3.get_xticklabels(), rotation=45, ha="right")
    ax3.set_xlabel("Categor√≠a de Reflexi√≥n")
    ax3.set_ylabel("Frecuencia")
    ax3.legend(title="Tipo")
    for container in ax3.containers:
        ax3.bar_label(container, fmt='%d', label_type='edge', fontsize=12)
    plt.tight_layout()
    st.pyplot(fig3)


st.subheader("--------------------------------------------------------")
st.header("Muestra de frases")

# ---- Ejemplos de preguntas/dudas por categor√≠a ----
st.subheader("üéØ Ejemplos de preguntas/dudas por categor√≠a")
# Se elimina el NaN del selectbox
categoria_dudas = st.selectbox(
    "Selecciona una categor√≠a de dudas:",
    df["DudasFrecuentes"].dropna().unique()
)
# Se crea un DataFrame con las columnas 'num_entrevista' y 'frase'
df_dudas_table = df[df["DudasFrecuentes"] == categoria_dudas][["num_entrevista", "frase"]]
# Se establece 'num_entrevista' como √≠ndice para reemplazar el √≠ndice predeterminado
df_dudas_table = df_dudas_table.set_index("num_entrevista")
st.dataframe(df_dudas_table, use_container_width=True)

# ---- Ejemplos de reflexiones/comentarios por categor√≠a ----
st.subheader("üéØ Ejemplos de reflexiones/comentarios por categor√≠a")
# Se elimina el NaN del selectbox
categoria_reflexion = st.selectbox(
    "Selecciona una categor√≠a comentario:",
    df["Tiporeflexi√≥n"].dropna().unique()
)
# Se crea un DataFrame con las columnas 'num_entrevista' y 'frase'
df_reflexion_table = df[df["Tiporeflexi√≥n"] == categoria_reflexion][["num_entrevista", "frase"]]
# Se establece 'num_entrevista' como √≠ndice para reemplazar el √≠ndice predeterminado
df_reflexion_table = df_reflexion_table.set_index("num_entrevista")
st.dataframe(df_reflexion_table, use_container_width=True)


###############################################
#############################################



import plotly.express as px
import pandas as pd

# Filtrar solo el tipo "Comentario/reflexi√≥n"
df_comentarioreflexion = df[df["Tipo"] == "Comentario/reflexi√≥n"].copy()
df_comentarioreflexion['num_entrevista'] = df_comentarioreflexion['num_entrevista'].astype(str)

# Agrupar por 'num_entrevista' y calcular la media, SEM y cantidad de frases
df_grouped = df_comentarioreflexion.groupby('num_entrevista', as_index=False).agg({
    'sent_robertuito': ['mean', 'sem', 'count']
})
df_grouped.columns = ['num_entrevista', 'mean_robertuito', 'sem_robertuito', 'count_frases']

# Clasificar sentimiento (se asume que la funci√≥n clasificar_sentimiento est√° definida)
df_grouped['Sentimiento'] = df_grouped['mean_robertuito'].apply(clasificar_sentimiento)

# Calcular el intervalo de confianza (IC ~95%)
df_grouped['ci_robertuito'] = 1.96 * df_grouped['sem_robertuito']

# Mapeo de colores para cada categor√≠a de sentimiento
color_dict = {
    "Muy negativo": "darkred",
    "Negativo": "lightcoral",
    "Neutral": "gray",
    "Positivo": "lightgreen",
    "Muy positivo": "darkgreen"
}

# Crear gr√°fico interactivo con Plotly Express
fig_sentimiento = px.scatter(
    df_grouped,
    x="num_entrevista",
    y="mean_robertuito",
    color="Sentimiento",
    color_discrete_map=color_dict,
    error_y="ci_robertuito",
    labels={
        "num_entrevista": "N√∫mero de Entrevista",
        "mean_robertuito": "Puntuaci√≥n de Sentimiento"
    },
    title="Comparaci√≥n de Sentimientos Promedio por Entrevista (IC ~95%)",
    hover_data={
        "count_frases": True,
        "mean_robertuito": ':.2f',
        "ci_robertuito": ':.2f',
        "num_entrevista": False  # ya se muestra en el eje x
    }
)

# Agregar l√≠neas horizontales de referencia
fig_sentimiento.add_hline(y=0.3, line_dash="dash", line_color="green", opacity=0.3)
fig_sentimiento.add_hline(y=0, line_dash="dash", line_color="grey", opacity=0.3)
fig_sentimiento.add_hline(y=-0.3, line_dash="dash", line_color="red", opacity=0.3)

# Actualizar hovertemplate para incluir informaci√≥n detallada
fig_sentimiento.update_traces(
    hovertemplate=(
        "<b>Entrevista: %{x}</b><br>" +
        "Puntuaci√≥n: %{y:.2f}<br>" +
        "IC: ¬±%{error_y:.2f}<br>" +
        "Cantidad de frases: %{customdata[0]}<extra></extra>"
    ),
    customdata=df_grouped[['count_frases']].values
)

# Secci√≥n "An√°lisis de Sentimiento"
st.markdown("## An√°lisis de Sentimiento")
st.plotly_chart(fig_sentimiento, use_container_width=True)

import plotly.express as px
import pandas as pd

# Filtrar solo el tipo "Comentario/reflexi√≥n"
df_comentarioreflexion = df[df["Tipo"] == "Comentario/reflexi√≥n"].copy()
df_comentarioreflexion['num_entrevista'] = df_comentarioreflexion['num_entrevista'].astype(str)

# Agrupar por 'num_entrevista' y calcular la media, SEM y cantidad de frases
df_grouped = df_comentarioreflexion.groupby('num_entrevista', as_index=False).agg({
    'sent_robertuito': ['mean', 'sem', 'count']
})
df_grouped.columns = ['num_entrevista', 'mean_robertuito', 'sem_robertuito', 'count_frases']

# Clasificar sentimiento (se asume que la funci√≥n clasificar_sentimiento est√° definida)
df_grouped['Sentimiento'] = df_grouped['mean_robertuito'].apply(clasificar_sentimiento)

# Calcular el intervalo de confianza (IC ~95%)
df_grouped['ci_robertuito'] = 1.96 * df_grouped['sem_robertuito']

# Mapeo de colores para cada categor√≠a de sentimiento
color_dict = {
    "Muy negativo": "darkred",
    "Negativo": "lightcoral",
    "Neutral": "gray",
    "Positivo": "lightgreen",
    "Muy positivo": "darkgreen"
}

# Crear gr√°fico interactivo con Plotly Express
fig_sentimiento = px.scatter(
    df_grouped,
    x="num_entrevista",
    y="mean_robertuito",
    color="Sentimiento",
    color_discrete_map=color_dict,
    error_y="ci_robertuito",
    labels={
        "num_entrevista": "N√∫mero de Entrevista",
        "mean_robertuito": "Puntuaci√≥n de Sentimiento"
    },
    title="Comparaci√≥n de Sentimientos Promedio por Entrevista (IC ~95%)",
    hover_data={
        "count_frases": True,
        "mean_robertuito": ':.2f',
        "ci_robertuito": ':.2f',
        "num_entrevista": False  # ya se muestra en el eje x
    }
)

# Agregar l√≠neas horizontales de referencia
fig_sentimiento.add_hline(y=0.3, line_dash="dash", line_color="green", opacity=0.3)
fig_sentimiento.add_hline(y=0, line_dash="dash", line_color="grey", opacity=0.3)
fig_sentimiento.add_hline(y=-0.3, line_dash="dash", line_color="red", opacity=0.3)

# Actualizar hovertemplate para incluir informaci√≥n detallada
fig_sentimiento.update_traces(
    hovertemplate=(
        "<b>Entrevista: %{x}</b><br>" +
        "Puntuaci√≥n: %{y:.2f}<br>" +
        "IC: ¬±%{error_y:.2f}<br>" +
        "Cantidad de frases: %{customdata[0]}<extra></extra>"
    ),
    customdata=df_grouped[['count_frases']].values
)

# Secci√≥n "An√°lisis de Sentimiento"
st.markdown("## An√°lisis de Sentimiento")
st.plotly_chart(fig_sentimiento, use_container_width=True)
